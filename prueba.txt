public class EjerciciosArboles {

	public static int contarNodos(ArbolBin<Integer> arbol) {
		
		if (arbol.esVacio() == true) {
			return 0;
		} else {
			int izq = contarNodos(arbol.hijoIzquierdo());
			int der = contarNodos(arbol.hijoDerecho());

			return 1 + izq + der;
		}
	}

	public static int sumatorioNodos(ArbolBin<Integer> arbol) {
		if (arbol.esVacio() == true) {
			return 0;
		} else {
			int r = arbol.raiz();
			int izq = sumatorioNodos(arbol.hijoIzquierdo());
			int der = sumatorioNodos(arbol.hijoDerecho());
			return r + izq + der;
		}
	}

	public static int contarPares(ArbolBin<Integer> arbol) {
		if (arbol.esVacio() == true) {
			return 0;
		} else {
			if (arbol.raiz() % 2 == 0) {
				return 1 + contarPares(arbol.hijoIzquierdo()) + contarPares(arbol.hijoDerecho());
			} else {
				return contarPares(arbol.hijoIzquierdo()) + contarPares(arbol.hijoDerecho());
			}

		}
	}

	public static int contarNodosHoja(ArbolBin<Integer> arbol) {
		if (arbol.esVacio() == true) {
			return 0;
		} else {
			if (arbol.hijoIzquierdo().esVacio() == true && arbol.hijoDerecho().esVacio() == true) {
				return 1;
			} else {
				return contarNodosHoja(arbol.hijoIzquierdo()) + contarNodosHoja(arbol.hijoDerecho());
			}
		}
	}

	public static boolean sonIguales(ArbolBin<Integer> arbol, ArbolBin<Integer> arbol2) {

		if (arbol.esVacio() && arbol2.esVacio()) {

			return true;
		} else {
			if (arbol.esVacio() || arbol2.esVacio()) {
				return false;
			} else {
				if (arbol.raiz() != arbol2.raiz()) {
					return false;
				} else {
					return sonIguales(arbol.hijoIzquierdo(), arbol2.hijoIzquierdo())
							&& sonIguales(arbol.hijoDerecho(), arbol2.hijoDerecho());
				}
			}
		}
	}

	public static int nodoMaximo(ArbolBin<Integer> arbol) {
		if (arbol.esVacio()) {
			return 0;
		} else {
			int raiz = arbol.raiz();
			int raizI = nodoMaximo(arbol.hijoIzquierdo());
			int raizD = nodoMaximo(arbol.hijoDerecho());

			if (raiz > raizI && raiz > raizD) {
				return raiz;
			} else if (raizI > raiz && raizI > raizD) {
				return raizI;
			} else {
				return raizD;
			}

		}
	}

	public static void inorden(ArbolBin arbol) {
		if (!arbol.esVacio()) {
			inorden(arbol.hijoIzquierdo());
			// visitar(arbol.raiz());
			inorden(arbol.hijoDerecho());
		}
	}

	public static int profundidad(ArbolBin<Integer> arbol) {

		if (arbol.esVacio() == true) {
			return 0;
		} else {

			int izq = profundidad(arbol.hijoIzquierdo());
			int der = profundidad(arbol.hijoDerecho());

			if (izq > der) {
				return 1 + izq;
			} else {
				return 1 + der;
			}

		}

	}

	public static boolean esLleno(ArbolBin<Integer> arbol) {
		if (arbol.esVacio()) {
			return false;
		} else {
			int profundidad = profundidad(arbol);
			int nodos = contarNodos(arbol);
			if (Math.pow(2, profundidad) - 1 == nodos) {
				return true;
			} else {
				return false;
			}

		}
	}

	public static boolean esSesgado(ArbolBin<Integer> arbol) {
		if (arbol.esVacio()) {
			return false;
		} else {
			int hojas = contarNodosHoja(arbol);
			if (hojas == 1) {
				return true;
			} else {
				return false;
			}
		}
	}

	public static int contarNodosNivel(ArbolBin<Integer> arbol, int k) {
		if (arbol.esVacio()) {
			return 0;
		} else {
			if (k == 1) {
				return 1;
			} else {
				return contarNodosNivel(arbol.hijoIzquierdo(), k - 1) + contarNodosNivel(arbol.hijoDerecho(), k - 1);
			}
		}
	}

	public static boolean esCompleto(ArbolBin<Integer> arbol) {
		if (!arbol.esVacio()) {
			if (arbol.hijoIzquierdo().esVacio() && arbol.hijoDerecho().esVacio()) {
				return true;
			}
		}
		if (arbol.hijoIzquierdo().esVacio() && arbol.hijoDerecho().esVacio()) {
			if (esCompleto(arbol.hijoIzquierdo()) && esCompleto(arbol.hijoDerecho())) {
				return true;
			}
		}
		return false;
	}

	public static boolean esAvl(ArbolBin<Integer> arbol) {
		if (arbol.esVacio()) {
			return false;
		} else {
			int alturaizq = profundidad(arbol.hijoIzquierdo());
			int alturader = profundidad(arbol.hijoDerecho());
			int factoreq = alturaizq - alturader;
			if (factoreq <= 1) {
				if (esAvl(arbol.hijoIzquierdo()) && esAvl(arbol.hijoDerecho())) {
					return true;
				} else
					return false;
			} else
				return false;
		}
	}

	public static void main(String[] args) {

		// ArbolBin<Integer> g = new ArbolBin<Integer>(new ArbolBin<Character>(),'G',new
		// ArbolBin<Character>());
		// ArbolBin<Integer> x = new ArbolBin<Integer>(new ArbolBin<Integer>(),15 ,new
		// ArbolBin<Integer>());
		ArbolBin<Integer> d = new ArbolBin<Integer>(new ArbolBin<Integer>(), 4, new ArbolBin<Integer>());
		ArbolBin<Integer> f = new ArbolBin<Integer>(new ArbolBin<Integer>(), 6, new ArbolBin<Integer>());

		ArbolBin<Integer> e = new ArbolBin<Integer>(new ArbolBin<Integer>(), 5, f);
		ArbolBin<Integer> b = new ArbolBin<Integer>(d, 2, new ArbolBin<Integer>());
		ArbolBin<Integer> c = new ArbolBin<Integer>(e, 3, new ArbolBin<Integer>());

		ArbolBin<Integer> a = new ArbolBin<Integer>(b, 1, c);

		// System.out.println(contarNodos(a));
		// System.out.println(sumatorioNodos(a));
		// System.out.println(contarPares(a));
		// System.out.println(contarNodosHoja(a));
		// System.out.println(sonIguales(a,a));
		// System.out.println(nodoMaximo(a));
		// System.out.println(profundidad(a));
		// System.out.println(esLleno(a));
		// System.out.println(esSesgado(a));
		contarNodosNivel(a, 3);
		
		System.out.println(a.hijoIzquierdo());

	}

}
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////GRAFOS///////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
public class GrafoEjercicios<Clave, InfoVertice, Coste> {

	public static <Clave> void main(String args[]) {
		Grafo<String, String, Integer> gr = new Grafo<String, String, Integer>();

		/*
		 * gr.insertarVertice("RZS", "Las rozas"); gr.insertarVertice("MAJ",
		 * "Majadahonda"); gr.insertarVertice("TOR", "Torrelodones");
		 * gr.insertarVertice("POZ", "Pozuelo"); gr.insertarVertice("MAD", "Madrid");
		 * gr.insertarVertice("ARA", "Aranjuez"); gr.insertarVertice("TOL", "Toledo");
		 * gr.insertarVertice("GAL", "Galicia"); gr.insertarVertice("CUE", "Cuenca");
		 * gr.insertarVertice("MUR", "Murcia");
		 * 
		 * gr.insertarArista("RZS", "MAJ", 15);
		 * 
		 * gr.insertarArista("MAJ", "TOL", 20); gr.insertarArista("MAJ", "MAD", 20);
		 * 
		 * gr.insertarArista("MAD", "GAL", 20);
		 * 
		 * gr.insertarArista("GAL", "TOR", 20); gr.insertarArista("GAL", "CUE", 20);
		 * gr.insertarArista("GAL", "MUR", 20);
		 * 
		 * gr.insertarArista("POZ", "ARA", 20);
		 */

		gr.insertarVertice("RZS", "Las rozas");
		gr.insertarVertice("MAJ", "Majadahonda");
		gr.insertarVertice("TOR", "Torrelodones");
		gr.insertarVertice("POZ", "Pozuelo");

		gr.insertarArista("RZS", "MAJ", 15);

		gr.insertarArista("MAJ", "TOR", 20);
		gr.insertarArista("MAJ", "POZ", 20);

		gr.insertarArista("TOR", "POZ", 20);

		gr.insertarArista("POZ", "RZS", 20);

		// Ejercicio1(gr);
		// Ejercicio2(gr);
		// Ejercicio3(gr);
		// Ejercicio4(gr);
		// Ejercicio5(gr);
		// Ejercicios6(gr);
		// recorridoEnAnchura(gr);
		System.out.println(gradoDeUnGrafo(gr));
	}

	private static <Clave, Info, Coste> int gradoDeUnGrafo(Grafo<Clave, Info, Coste> gr) {
		int gradomax = 0;
		Lista<Clave> vertices = gr.listaVertices();
		for (int i = 1; i < vertices.longitud(); i++) {
			int gradoahora = gr.gradoEntrada(vertices.consultar(i)) + gr.gradoSalida(vertices.consultar(i));
			if (gradoahora > gradomax) {
				gradomax = gradoahora;
			}
		}

		return gradomax;

	}

	private static void Ejercicios6(Grafo<String, String, Integer> gr) {
		/*
		 * 6. Implementar un procedimiento que cuente el nÃºmero de ciclos simples
		 * existentes en un grafo nod dirigido.
		 */

		// NOTA: Un ciclo es un camino que empieza en un vertice y acaba en el tambiÃ©n.
		// El ciclo es simple si pasa por varios vertices
		int ciclos = contarNumeroDeCiclosEnGrafoNoDirigido(gr);
		System.out.println("El numero de ciclos del grafo es: " + ciclos);

	}

	private static int contarNumeroDeCiclosEnGrafoNoDirigido(Grafo<String, String, Integer> gr) {
		// TODO Auto-generated method stub

		return 0;
	}

	private static void Ejercicio5(Grafo<String, String, Integer> gr) {
		/*
		 * 5. * Sea G un grafo dirigido. Se pide construir un procedimiento que escriba
		 * los identificadores de los vÃ©rtices del grafo en diferentes lÃ­neas segÃºn el
		 * siguiente criterio: 1Âª lÃ­nea: v 2Âª lÃ­nea: vÃ©rtices situados a 1 arista de
		 * distancia desde v (si existen) 3Âª lÃ­nea: vÃ©rtices situados a 2 aristas de
		 * distancia desde v (si existen) ... i-Ã©sima lÃ­nea: vÃ©rtices situados a (i-1)
		 * aristas desde v (si existen) ... Ãºltima lÃ­nea: vÃ©rtices no accesibles desde v
		 * (si existen) Nota: cada vÃ©rtice se imprimirÃ¡ sÃ³lo una vez a la distancia mas
		 * corta que le corresponda.
		 */

	}

	private static <Clave, Info, Coste> void Ejercicio1(Grafo<Clave, Info, Integer> gr) {
		/*
		 * 1. Sea G un grafo dirigido implementado con una matriz de adyacencia. Se
		 * pide: A. Realizar la declaraciÃ³n (archivo de cabeceras) de la clase Grafo
		 * correspondiente. B. Construir un mÃ©todo que, dados v y G, siendo v un vÃ©rtice
		 * del grafo G, obtenga todos los vÃ©rtices de G desde los cuales sea accesible
		 * v. Nota: Se dice que v es accesible desde el vÃ©rtice X si existe un camino
		 * desde X a v
		 */

		Lista<Clave> accesibles = (Lista<Clave>) verticesAccesiblesDesdeUnVertice(gr, (Clave) "RZS");
		System.out.println("Los vertices desde los que TOR es accesible: ");
		for (int i = 1; i < accesibles.longitud(); i++) {
			System.out.print(accesibles.consultar(i) + " - ");
		}

	}

	private static <Clave, Info, Coste> void Ejercicio2(Grafo<Clave, Info, Coste> gr) {
		/*
		 * 2. * Dado un grafo no dirigido, escribir un procedimiento que obtenga todas
		 * sus componentes conexas, escribiendo los identificadores de los vÃ©rtices de
		 * cada componente en una lÃ­nea distinta.
		 */

		Lista<Lista<Clave>> componentesConexas = componentesConexasGrafoNoDirigido(gr);
		System.out.println("Las coponentes conexas del grafo son las siguientes:  ");
		for (int i = 1; i <= componentesConexas.longitud(); i++) {
			System.out.print(componentesConexas.consultar(i));
			System.out.println();
			System.out.println("Siguiente componente conexa: ");
		}

	}

	private static <Clave, Info, Coste> void Ejercicio3(Grafo<Clave, Info, Coste> gr) {
		/*
		 * 3. * Sea G un grafo dirigido, se define la PROFUNDIDAD de G desde el vÃ©rtice
		 * v como la mÃ¡xima distancia desde v al resto de los vÃ©rtices de G (Nota: si
		 * existen varios caminos de v a w, la distancia de v a w es el nÃºmero de
		 * aristas del camino mas corto)
		 */

		int profundidad = maxProfundidadGrafoDesdeVertice(gr, (Clave) "MAJ");
		System.out.println("La profundidad del grafo desde el vertice es: " + profundidad);
	}

	private static <Clave, Info, Coste> void Ejercicio4(Grafo<Clave, Info, Integer> gr) {
		/*
		 * 4. En un digrafo, se dice que un vÃ©rtice es una fuente si tiene un grado de
		 * entrada nulo y un grado de salida positivo; anÃ¡logamente, se dice que un
		 * vÃ©rtice es un sumidero si tiene un grado de entrada positivo y un grado de
		 * salida nulo. Escribir un procedimiento (haciendo uso de las operaciones
		 * proporcionadas por la clase Grafo, y suponiendo que existe la operaciÃ³n
		 * grado(Vertice), pero no gradoEntrada(Vertice) ni gradoSalida(Vertice)) que
		 * detecte fuentes y sumideros en un digrafo. Determinar el orden de
		 * complejidad.
		 */
		Lista<Clave> fuentes = new Lista();
		Lista<Clave> sumideros = new Lista();
		contarVerticesFuenteYSumidero(gr, fuentes, sumideros);

	}

	private static <Clave, Info, Coste> Lista<Lista<Clave>> componentesConexasGrafoNoDirigido(
			Grafo<Clave, Info, Coste> gr) {
		Lista<Clave> noVisitados = gr.listaVertices();
		Lista<Lista<Clave>> listaDeGrupos = new Lista();
		Clave vertice;
		while (!noVisitados.esVacia()) {
			vertice = noVisitados.consultar(1);
			Lista<Clave> grupo = recorridoEnProfRec(gr, noVisitados, new Lista(), vertice);
			listaDeGrupos.insertar(1, grupo);
		}
		return listaDeGrupos;
	}

	private static <Clave, Info, Coste> int contarVerticesAislados(Grafo<Clave, Info, Coste> gr) {
		// TODO Auto-generated method stub
		Lista<Clave> vertices = gr.listaVertices();
		int contador = 0;
		for (int i = 1; i <= vertices.longitud(); i++) {
			Clave v = vertices.consultar(i);
			if (gr.gradoEntrada(v) == 0 && gr.gradoSalida(v) == 0) {
				contador = contador + 1;
			}
		}

		return contador;

	}

	public static <Clave, Info, Coste> void contarVerticesFuenteYSumidero(Grafo<Clave, Info, Coste> gr,
			Lista<Clave> fuentes, Lista<Clave> sumideros) {

		Lista<Clave> vertices = gr.listaVertices();
		for (int i = 1; i < vertices.longitud(); i++) {
			Clave claveahora = vertices.consultar(i);
			if (gr.gradoSalida(claveahora) > 0 && gr.gradoEntrada(claveahora) == 0)
				fuentes.insertar(1, claveahora);
			if (gr.gradoEntrada(claveahora) > 0 && gr.gradoSalida(claveahora) == 0)
				sumideros.insertar(1, claveahora);

		}

		System.out.println("El numero de vertices fuente es: " + fuentes.longitud());
		System.out.println("El numero de vertices sumideros es: " + sumideros.longitud());
	}

	public static <Clave, Info, Coste> int contarBucles(Grafo<Clave, Info, Coste> gr) {

		return 0;
	}

	public static <Clave, Info, Coste> int recorridoEnAnchura(Grafo<Clave, Info, Coste> gr) {
		Lista<Clave> noVisitados = gr.listaVertices();
		Lista<Clave> cola = new Lista<Clave>();
		Clave vertice;

		while (!noVisitados.esVacia()) {
			vertice = noVisitados.consultar(1);
			cola.insertar(cola.longitud() + 1, vertice);

			while (cola.esVacia() == false) {
				vertice = cola.consultar(1);
				cola.borrar(1);
				if (noVisitados.buscar(vertice) != 0) {
					System.out.print(vertice + "->");
					noVisitados.borrar(noVisitados.buscar(vertice));
					Lista<Clave> sucesores = gr.listaSucesores(vertice);
					for (int i = 1; i <= sucesores.longitud(); i++) {
						cola.insertar(cola.longitud() + 1, sucesores.consultar(i));
					}
				}
			}
		}

		return 0;
	}

	public static <Clave, Info, Coste> Lista<Clave> verticesAccesiblesDesdeUnVertice(Grafo<Clave, Info, Coste> gr,
			Clave origen) {

		Lista<Clave> accesibles = new Lista();
		Clave vertice = null;
		int i = 1;
		while (i <= gr.listaVertices().longitud() && !gr.listaVertices().consultar(i).equals(origen))
			i++;

		if (i <= gr.listaVertices().longitud())
			vertice = gr.listaVertices().consultar(i);

		accesibles = recProfRecDeUnVertice(gr, gr.listaVertices(), accesibles, vertice);

		// accesibles.borrar(accesibles.longitud());
		return accesibles;
	}

	private static <Clave, Info, Coste> Lista<Clave> recProfRecDeUnVertice(Grafo<Clave, Info, Coste> gr,
			Lista<Clave> noVisitados, Lista<Clave> accesibles, Clave vertice) {

		Lista<Clave> sucesores;
		Lista<Clave> predecesores;

		noVisitados.borrar(noVisitados.buscar(vertice));
		accesibles.insertar(1, vertice);

		Clave destino = null;
		sucesores = gr.listaSucesores(vertice);
		for (int i = 1; i <= sucesores.longitud(); i++) {
			destino = sucesores.consultar(i);
			if (noVisitados.buscar(destino) != 0) {
				recProfRecDeUnVertice(gr, noVisitados, accesibles, destino);
			}
		}

		Clave origen = null;
		predecesores = gr.listaPredecesores(vertice);
		for (int i = 1; i <= predecesores.longitud(); i++) {
			origen = predecesores.consultar(i);
			if (noVisitados.buscar(origen) != 0) {
				recProfRecDeUnVertice(gr, noVisitados, accesibles, origen);
			}
		}
		return accesibles;

	}

	private static <Clave, Info, Coste> Lista<Clave> recorridoEnProfRec(Grafo<Clave, Info, Coste> gr,
			Lista<Clave> noVisitados, Lista<Clave> visitados, Clave vertice) {

		noVisitados.borrar(noVisitados.buscar(vertice));
		visitados.insertar(1, vertice);

		Lista<Clave> sucesores = gr.listaSucesores(vertice);

		Clave destino;
		for (int i = 1; i <= sucesores.longitud(); i++) {
			destino = sucesores.consultar(i);
			if (noVisitados.buscar(destino) != 0) {
				recorridoEnProfRec(gr, noVisitados, visitados, destino);
			}
		}
		return visitados;

	}

	private static <Clave, Info, Coste> Lista<Clave> recProfRecDeUnVerticePrimeroSucesores(Grafo<Clave, Info, Coste> gr,
			Lista<Clave> noVisitados, Lista<Clave> accesibles, Clave vertice) {

		Lista<Clave> sucesores;
		Lista<Clave> predecesores;

		noVisitados.borrar(noVisitados.buscar(vertice));
		accesibles.insertar(1, vertice);

		Clave destino = null;
		sucesores = gr.listaSucesores(vertice);
		for (int i = 1; i <= sucesores.longitud(); i++) {
			destino = sucesores.consultar(i);
			if (noVisitados.buscar(destino) != 0) {
				recProfRecDeUnVertice(gr, noVisitados, accesibles, destino);
			}
		}

		return accesibles;

	}

	private static <Clave, Info, Coste> Lista<Clave> recProfRecDeUnVerticePrimeroPredecesores(
			Grafo<Clave, Info, Coste> gr, Lista<Clave> noVisitados, Lista<Clave> accesibles, Clave vertice) {

		Lista<Clave> sucesores;
		Lista<Clave> predecesores;

		noVisitados.borrar(noVisitados.buscar(vertice));
		accesibles.insertar(1, vertice);

		Clave origen = null;
		predecesores = gr.listaPredecesores(vertice);
		for (int i = 1; i <= predecesores.longitud(); i++) {
			origen = predecesores.consultar(i);
			if (noVisitados.buscar(origen) != 0) {
				recProfRecDeUnVertice(gr, noVisitados, accesibles, origen);
			}
		}
		return accesibles;

	}

	private static <Clave, Info, Coste> int maxProfundidadGrafoDesdeVertice(Grafo<Clave, Info, Coste> gr,
			Clave vertice) {

		Lista<Clave> profundidadPredecesores = new Lista();
		profundidadPredecesores = recProfRecDeUnVerticePrimeroPredecesores(gr, gr.listaVertices(), new Lista(),
				vertice);
		profundidadPredecesores.borrar(profundidadPredecesores.longitud());

		Lista<Clave> profundidadSucesores = new Lista();
		profundidadSucesores = recProfRecDeUnVerticePrimeroSucesores(gr, gr.listaVertices(), new Lista(), vertice);
		profundidadSucesores.borrar(profundidadSucesores.longitud());

		if (profundidadPredecesores.longitud() > profundidadSucesores.longitud())
			return profundidadPredecesores.longitud();
		else
			return profundidadSucesores.longitud();

	}
	
	
	
		public static int contarBucles(Grafo<String, String, Integer> grafo) {
		Lista<String> vertice_sucesor = new Lista<String>();
		Lista<String> vertice = new Lista<String>();
		vertice = grafo.listaVertices();// vertices:A,B,C,D

		int cont_vertices_bucle = 0;
		for (int i = 1; i <= vertice.longitud(); i++) {
			String aux = vertice.consultar(i);
			vertice_sucesor = grafo.listaSucesores(aux);// sucesores de A,
														// sucesores de B,
														// sucesores de C,

			if (vertice_sucesor.buscar(aux) != 0) {// .buscar te debuelve el int
													// de la posicion, si te
													// devuelve 0 es que no esta
				cont_vertices_bucle++;
			}

		}
		return cont_vertices_bucle;
	}

	public static int contarAislados(Grafo<String, String, Integer> grafo) {
		Lista<String> vertice = new Lista<String>();
		vertice = grafo.listaVertices();
		int cont_vertices_aislados = 0;

		for (int i = 1; i <= vertice.longitud(); i++) {
			String aux = vertice.consultar(i);
			if (grafo.gradoEntrada(aux) == 0 && grafo.gradoSalida(aux) == 0) {
				cont_vertices_aislados++;
			}
		}

		return cont_vertices_aislados;

	}

	// funcion que es un vertice fuente, es el que tiene solo salidas
	// sumidero es el que entran todas las flechas
	// devuelva una lista con todas las vertices fuente, y otro listado con solo
	// los vertices sumidero

	public static void contarFuentesySumideros(Grafo<String, String, Integer> grafo, Lista<String> fuentes,
			Lista<String> sumideros) {
		Lista<String> vertice = new Lista<String>();
		vertice = grafo.listaVertices();

		for (int i = 1; i <= vertice.longitud(); i++) {// para cada vertice del
														// grafo
			String aux = vertice.consultar(i);
			if (grafo.gradoEntrada(aux) == 0 && grafo.gradoSalida(aux) > 0) {
				fuentes.insertar(1, aux);// el insertar empieza por el primero,
											// el que estaba el primero pasa a
											// ser el segundo
				// fuentes.insertar(fuentes.longitud()+1, aux);inserta por el
				// final
			}
			if (grafo.gradoSalida(aux) == 0 && grafo.gradoEntrada(aux) > 0) {
				sumideros.insertar(1, aux);// el insertar empieza por el primero
			}
		}

	}

	// funcion recorrido en anchura. mientras la cola no este vacia, voy
	// metiendo sucesores al vertice
	// me pasan un grafo, lista de vertices, con la cola, pregunto por sus
	// sucesores y meto en la cola
	public static void recorridoEnAnchura(Grafo<String, String, Integer> grafo) {
		Lista<String> vertice = new Lista<String>();
		vertice = grafo.listaVertices();
		Lista<String> lista_sucesores = new Lista<String>();

		for (int i = 1; i <= vertice.longitud(); i++) {// para cada vertice del
														// grafo
			String aux = vertice.consultar(i);
			lista_sucesores = grafo.listaSucesores(aux);
			for (int j = 0; j < lista_sucesores.longitud(); j++) {
				System.out.println();
			}
		}

	}
	
	public static void recAnchura (Grafo <String, String, Integer> grafo){
		Lista<String> NoVisitados = grafo.listaVertices();
		Lista<String> cola = new  Lista<String>();
		String vertice;
	
		while(!NoVisitados.esVacia()){
			vertice = NoVisitados.consultar(1);
			cola.insertar(cola.longitud()+1, vertice);
			while(!cola.esVacia()){
				vertice = cola.consultar(1);
				cola.borrar(1);
				if(NoVisitados.buscar(vertice)!=0){
					System.out.print(vertice+" - ");
					NoVisitados.borrar(NoVisitados.buscar(vertice));
					Lista<String> sucesores = grafo.listaSucesores(vertice);
					for(int i=1; i<=sucesores.longitud();i++){
						cola.insertar(cola.longitud()+1, sucesores.consultar(i));
					}
				}
			}
		}

	}
	
	public static boolean esConexo(Grafo <String, String, Integer> grafo){
		Lista<String> vertices = grafo.listaVertices();
		String vertice;
		boolean conexo = true;
		int contador=1;
		while(conexo==true && contador <= vertices.longitud()){
			vertice=vertices.consultar(contador);
			if(grafo.gradoSalida(vertice)==0 && grafo.gradoEntrada(vertice)==0){
				
				conexo = false;
			}
			contador++;
		}
		
		return conexo;
	}
	
	
	public static void recA(Grafo <String, String, Integer> grafo){
	
	Lista<String> noVisitados = grafo.listaVertices();
	Lista<String> cola = new Lista<String>();
	String vertice ;
	
	while(noVisitados.esVacia()==false){
		vertice = noVisitados.consultar(1);
		cola.insertar(cola.longitud()+1, vertice);
		
		while(cola.esVacia()==false){
			vertice = cola.consultar(1);
			cola.borrar(1);
			if(noVisitados.buscar(vertice)!=0){
				System.out.print(vertice+"->");
				noVisitados.borrar(noVisitados.buscar(vertice));
				Lista<String> sucesores = grafo.listaSucesores(vertice);
				for(int i = 1;i<=sucesores.longitud();i++){
					cola.insertar(cola.longitud()+1, sucesores.consultar(i));
				}
			}
		}
	}
		
	}
	
	public static void recP(Grafo <String, String, Integer> grafo){
		Lista<String> noVisitados = grafo.listaVertices();
		String vertice;
		
		while(noVisitados.esVacia()==false){
			vertice = noVisitados.consultar(1);
			recPRec(grafo,noVisitados,vertice);
		}
		
	}
	
	public static void recPRec(Grafo <String, String, Integer> grafo,Lista<String> noVisitados,String vertice){
		System.out.println(vertice+"->");
		noVisitados.borrar(noVisitados.buscar(vertice));
		Lista<String> sucesores = grafo.listaSucesores(vertice);
		String destino;
		for(int i = 1;i<=sucesores.longitud();i++){
			destino = sucesores.consultar(1);
			if(noVisitados.buscar(destino)!=0)
			recPRec(grafo,noVisitados,destino);
		}
		
	}
		public static int contarAislados ( Grafo<String, String, Integer> grafo){
		Lista<String> vertices = grafo.listaVertices();
		int aislados = 0;
		for(int i = 1; i<=vertices.longitud();i++){
			String v = vertices.consultar(i);
			if(grafo.gradoEntrada(v) == 0 && grafo.gradoSalida(v)== 0){
				aislados++;
			}
		}
	return aislados;
	}
	
	public static boolean compararGrafosV1(Grafo<String, String, Integer> A ,Grafo<String, String, Integer> B){
		Lista<String> verticesA = A.listaVertices();
		Lista<String> verticesB = B.listaVertices();
		String vertice;
		boolean iguales=true;
		if(verticesA.longitud() != verticesB.longitud()){
			iguales=false;
		}
		int cont = 1;
		while(iguales==true && cont<= verticesA.longitud()){
			if(verticesA.consultar(cont) != verticesB.consultar(cont)){
				iguales = false;
			}else{
				iguales = true;
			}
			cont++;
		}	
		int contador = 1;
		while(iguales==true && contador<=verticesA.longitud()){
			vertice = verticesA.consultar(contador);
			Lista<String> sucesoresA = A.listaSucesores(vertice);
			Lista<String> sucesoresB = B.listaSucesores(vertice);
			if(sucesoresA.longitud()!=sucesoresB.longitud()){
				iguales=false;
			}
			int contador2=1;
			while(iguales==true && contador2<=sucesoresA.longitud()){
			if(sucesoresA.consultar(contador2) != sucesoresB.consultar(contador2)){
				iguales = false;
			}
			contador2++;
			}
			contador++;
		}
		
	return iguales;
	}
	
	
	
	public static int contarBucles(Grafo<String, String, Integer> grafo){
		Lista<String> vertices = grafo.listaVertices();
		int bucles = 0;
		for(int i = 1; i<=vertices.longitud();i++){
			String v = vertices.consultar(i);
			if(grafo.listaSucesores(v).buscar(v)!=0){
				bucles++;
			}
		}
		return bucles;
	}

}
